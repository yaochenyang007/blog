---
title: 前端面试分享
date: 2019-02-22 14:30:06
tags:  [vue,canvas,css,javascript]
categories: 面试
---



### JavaScript call,aplay,bind异同


call 和 apply 。这两个函数都是在特定的作用域中调用函数,能改变函数的作用域，实际上是改变函数体内 this 的值 。
call传递多个参数。
apply传递多个参数的时候第二个参数需要传递一个数组。

bind用来改变this的指向，返回一个修改过的函数，该函数不会被执行。

用一个对象的一个方法，以另一个对象替换当前对象。
<!--- more --->
```
var a = {
    user:"Ice",
    fn:function(){
        console.log(this.user); //Ice
    }
}


var b = a.fn;
b.apply(a); //将a对象的this赋值给b对象,
b.call(a); //将a对象的this赋值给b对象,
//如果call和apply的第一个参数写的是null，那么this指向的是window对象

```

bind用来改变this的指向，返回一个修改过的函数，该函数不会被执行
```
var a = {
    user:"Ice",
    fn:function(){
        console.log(this.user); 
    }
}
var b = a.fn;
var c = b.bind(a);
c();//Ice
```

调用函数，传递参数
```
  //定义一个add 方法
    function add(x, y) {
        return x + y;
    }

    //用call 来调用 add 方法
    function myAddCall(x, y) {
        //调用 add 方法 的 call 方法
        return add.call(this, x, y);
    }

    //apply 来调用 add 方法
    function myAddApply(x, y) {
        //调用 add 方法 的 applly 方法
        return add.apply(this, [x, y]);
    }

    console.log(myAddCall(10, 20));    //输出结果30
  
    console.log(myAddApply(20, 20));  //输出结果40

    
```


高级用法，实现 js 继承 ，子类继承父类的方法。

```
//父类Person
function Person(){
    this.Name = function(){
       return this.name;
    }
}

//子类Chinese
function Chinese(name){
        
        Person.call(this); //将对象Chinese的this赋值给对象Person,
        this.name = name;  //此时this是指父类Person的this;
}

//子类America
function America(name){
        Person.apply(this);  //将对象America的this赋值给对象Person,
         this.name = name; //此时this是指父类Person的this;
}

var chinese = new Chinese("我是中国人");

chinese.Name();  //我是中国人


var america = new America("我是美国人");

america.Name();  //我是美国人



```

###  实例化new 操作过程
要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4
个步骤：

```
var person =  new Person();

```
等价于

```
var person  = {};
person.__proto__ = Person.prototype;
Person.call(person);
第一行，我们创建了一个空对象person
第二行，我们将这个空对象的__proto__成员指向了Person函数对象prototype成员对象
第三行，我们将Person函数对象的this指针替换成person，然后再调用Person函数，于是我们就给person对象赋值了一个id成员变量。
```
(1) 创建一个新对象;
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。

###   prototype和 __proto__的区别
任意一个函数（包括构造函数）都有一个prototype属性，指向该函数的原型对象，同样任意一个构造函数实例化的对象，都有一个__proto__属性。

```

function a() {
    //console.log("I'am a function.");
}
//b是实例化对象，a是构造函数
var b = new a();

console.log(b.__proto__ == a.prototype);  //true
console.log(Object.getPrototypeOf(b) == a.prototype);  //true,标准方法返回的结果和上述一样

```

区别
```
//注意：a作为构造函数时的prototype属性与a作为普通函数时的__proto__属性并不相等
console.log(a.prototype == a.__proto__);//false

//这个怎么理解呢，我们再看看如下代码
console.log(a.__proto__);         //function (){}
console.log(a.__proto__ == Function.prototype);//true

//实际上，a作为一个普通函数调用的时候，它的构造函数就是内置对象Function了，所以它指向的原型对象，自然对应就是Function.prototype.
//其实这个和console.log(b.__proto__ == a.prototype)是一样的道理

//我们继续看如下代码，当a作为构造函数时，它的原型，和它的原型的原型都指向神马
console.log(a.prototype);                   //a{}
console.log(a.prototype.__proto__);  //Object{}

//我们再看看a作为普通函数时，它原型的原型指向神马
console.log(a.__proto__.__proto__); //Object{}

//即有以下结果
console.log(a.__proto__.__proto__ == a.prototype.__proto__); //true

```
结论:
prototype是构造函数访问原型对象，__proto__是对象实例访问原型对象。


###   什么是事件委托吗？

事件委托就是利用冒泡的原理，把事件加到父元素或祖先元素上，触发执行效果。


```
<input type="button" value="click me" id="btn6">

var btn6 = document.getElementById("btn6");
document.onclick = function(event){
	event = event || window.event;
	var target = event.target || event.srcElement;
	if(target == btn6){
		alert(btn5.value);
	}
}

```
在实际的代码中 我们可能用到jQuery的live()、delegate()、bind()、on()等。
事件委托优点
1、提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用。 实例分析JavaScript中的事件委托和事件绑定 


###    Promise原理