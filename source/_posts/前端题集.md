---
title: 前端题集
date: 2019-12-04 09:33:52
tags: [web]
categories: 面试
---

### web性能优化

![本地图片](/img/performanceoptimization.jpg  "性能优化")

#### 资源合并与压缩

##### html压缩
    使用在线网站进行，
    压缩nodejs提供了html-minifier
    工具后端模版引擎渲染压缩）
##### css及js压缩
    使用在线网站进行压缩
    使用html-minifier对html中的css进行压缩
    使用clean-css对css进行压缩
##### 文件合并
    公共库合并
    不同页面的合并
    随机应变，根据业务场景作出抉择，选出最优方案
    使用在线网站进行文件合并
    使用nodejs实现文件合并
##### 图片压缩
    css雪碧图
    image inline（将图片内容嵌入到html中，减少http网络请求）
    矢量图（使用svg进行矢量图的绘制使用iconfont解决icon问题）

<!--- more --->
#### 懒加载
    图片进入可视区域之后请求资源
    对于电商等图片很多，页面很长的业务场景适用
    减少无效资源的加载
    并发加载的资源过多会阻塞js的加载，影响网站的正常使用
#### 预加载
    图片等静态资源在使用之前的提前请求
    资源使用到时能从缓存中加载，提升用户体验
    页面展示的依赖关系维护
#### 回流
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)
盒子模型相关属性会触发重布局
定位属性及浮动也会触发重布局
改变节点内部文字结构也会触发重布局
添加或删除DOM节点
浏览器窗口尺寸改变
#### 重绘
当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。
#### 浏览器存储
localstorage、sessionstorage、cookie和manifest(离线存储)

#### 缓存优化

##### 缓存的位置
1.Service Worker（运行在浏览器背后的独立线程）
2.Memory Cache（内存中的缓存）
3.Disk Cache（存储在硬盘中的缓存）

#### 缓存策略都是通过设置 HTTP Header 来实现的。

###### 强制缓存(Expires和Cache-Control)
1.Expires
缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

2.Cache-Control
在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

###### 协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)

#### 缓存机制 

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。

#### 用户操作行为 

打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。
普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。
强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。



### web安全问题及防控方式

####  XSS ( 跨站脚本攻击 )
定义: 恶意攻击者通过往web页面嵌入恶意的js脚本，当用户浏览时，恶意的代码会被执行， 达到恶意攻击用户控制浏览器的目的. xss是代码注入的一种.
##### Reflected XSS 反射型
例如: 搜索关键词填入<script>alert('handsome boy')</script>, 点击搜索。页面没有对关键词进行过滤，这段代码就会直接在页面上执行，弹出 alert
##### Stored  XSS 存储型
攻击者将恶意数据存储到服务端的数据库中, 服务器脚本从数据库中获取该数据后, 没有进行安全处理即显示在公开页面上, 受害者访问该页面即中招. 一般提交的内容都是通过一些富文本编辑器编辑的，很容易插入危险代码
#####  Dom型
由js脚本动态创建, 输出到页面造成的. 此类型不需要经过服务器.
######  防御方法
永远不要相信用户的输入: 输入过滤, 输出转义
输入: 非字符串或有固定值时, 事先进行类型/值检查
输出: 进行html转义(如<转义为&lt
callback参数只允许字母, 数字, 下划线

####  CSRF(跨站请求伪造)
定义: 链接的表单提交的所有请求参数都可被预测, 攻击者构造好一个站内URL或在第三方网站设置一个自动提交的表单, 当合法用户在登录状态时, 攻击者诱使其点击, 此时就会在不知情的情况下执行了攻击者伪造的请求
######  防御方法
对所有涉及增删改的操作添加csrftoken, 并于服务端验证: 1. 服务端生成csrftoken, 放入服务端session, 放入前端cookie中; 2. 前端url通过js抓取cookie内容带入请求head中; 3. 服务端获取head中csrftoken与之前放入的session的做比较，在请求头中添加token字段用于检验权限。

####  Jsonp劫持
定义: 为了解决跨域问题, 使用jsonp方式传输数据, 由于数据很难做到权限校验, 攻击者可以构造带有该jsonp接口的恶意页面, 发给用户点击, 从而用户的敏感数据通过jsonp接口传输到攻击者的服务器上.
例如
```
<html>
	<script>
		function aaa(data) {
			// 发送data到攻击者服务器
		}
	</script>
	<script src="http://a.com/get?callback=aaa" />
</html>
```
######  防御方法
敏感数据尽量不要采用JSONP跨域传输.
如果需要, JSONP接口的后端需要对referer进行校验, 只允许受信任的调用方域名的页面里嵌入我们的JSONP或者token
域名是否受信任, 可使用安全包的URL白名单校验函数检查
callback 函数名词最长 50 个字符限制
callback 函数名只允许[,], a-zA-Z0123456789_,$, .，防止一般的 XSS，utf-7 XSS等攻击

####  钓鱼攻击

#####  URL钓鱼
服务端未对传入的跳转 url 变量进行检查和控制，可能导致可恶意构造任意一个恶意地址，诱导用户跳转到恶意网站。 由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击

###### 防御方法
若跳转的 url 事先是可以确定的，包括 url 和参数的值，则可以在后台先配置好，url 参数只需传对应 url 的索引即可，通过索引找到对应具体 url 再进行跳转；
若跳转的 url 事先不确定，但其输入是由后台生成的（不是用户通过参数传人），则可以先生成好跳转链接然后进行签名；
若 1 和 2 都不满足，url 事先无法确定，只能通过前端参数传入，则必须在跳转的时候对 url 进行按规则校验：判断 url 是否在应用授权的白名单内

####   SSRF 服务端请求伪造
一般来说，SSRF 安全漏洞常见于开发者在服务端直接请求客户端传递进来的 URL 资源，一旦攻击者传入一些内部的 URL 即可发起 SSRF 攻击。
###### 防御方法
配置黑白名单

#### 特别感谢
- [刘翾](https://blog.csdn.net/c_kite/article/details/80868597#3_Jsonp_48)
###   HTTPS连接过程以及中间人攻击劫持
中间人截取客户端发送给服务器的请求，然后伪装成客户端与服务器进行通信；将服务器返回给客户端的内容发送给客户端，伪装成服务器与客户端进行通信。 
通过这样的手段，便可以获取客户端和服务器之间通信的所有内容。 
使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。
###### 防御方法
造成中间人劫持的原因是 没有对服务端证书及域名做校验或者校验不完整，通过校验域名，证书有效性、证书关键信息及证书链的方式
客户端预埋证书的方式锁死证书

### vue从data改变到页面渲染的过程

1.通过Watcher监听数据的变化,
2.当数据发生变化时，Render函数执行生成VNode对象
3.DOM模型树通过DOM Diff算法查找差异，将差异转为真正DOM节点
3.通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素

#### vue 页面渲染提供了三种方式

##### 自定义render函数
```
1.Vue.component('anchored-heading', {
2.    render: function (createElement) {
3.        return createElement(
4.            'h' + this.level,   // tag name 标签名称
5.            this.$slots.default // 子组件中的阵列
6.        )
7.    },
8.    props: {
9.        level: {
10.            type: Number,
11.            required: true
12.        }
13.    }
14.})
```
##### template
```
1.var vm = new Vue({
2.    data: {
3.        // 以一个空值声明 `msg`
4.        msg: ''
5.    },
6.    template: '<div>{{msg}}</div>'
7.})
```
##### el
```
1.var app = new Vue({
2.    el: '#app',
3.    data: {
4.        message: 'Hello Vue!'
5.    }
6.})
```

### 从地址栏输入url到页面渲染出来，整个过程经历了什么

1、DNS解析URL的过程(Domain Name System,域名系统) 

2、浏览器发送请求与服务器交互的过程

3、浏览器对接收到的html页面渲染的过程

DNS解析URL的过程

    1）浏览器缓存：浏览器会按照一定的频率 缓存DNS记录

 　　2）操作系统缓存：如果浏览器缓存中找不到需要的DNS记录，就会取操作系统中找

　　 3）路由缓存：路由器也有DNS缓存

　　 4）ISP的DNS服务器：ISP有专门的DNS服务器应对DNS查询请求

　　 5）根服务器：ISP的DNS服务器找不到之后，就要向根服务器发出请求，进行递归查询

浏览器发送请求

　　1）首先浏览器利用tcp协议通过三次握手与服务器建立连接

　　http请求包括header和body。header中包括请求的方式（get和post）、请求的协议 （http、https、ftp）、请求的地址ip、缓存cookie。body中有请求的内容。

　　2）浏览器根据解析到的IP地址和端口号发起http的get请求.

　　3）服务器接收到http请求之后，开始搜索html页面，并使用http返回响应报文

　　4）若状态码为200显示响应成功，浏览器接收到返回的html页面之后，开始进行页面的渲染


浏览器渲染过程

    1）浏览器根据深度遍历的方式把html节点遍历成dom 树

    2）将css解析成CSS DOM树

    3）将dom树和CSS DOM树构造成render树

    4）JS根据得到的render树 计算所有节点在屏幕中的位置，进行布局（回流）

    5）遍历render树并调用硬件API绘制所有节点（重绘）


###  浏览器利用tcp协议通过三次握手与服务器建立连接,tcp四次握手,具体流程.

#### 三次握手
SYN_SENT（发送）, SYN_RCVD（同步接收）,ESTABLISHED（已确认的）

第一次握手 
    client客户端发送报文数据包到服务端server，等待服务端确认，客户端SYN_SENT（发送）状态
第二次握手
    服务端收到客户端报文数据包，确认客户端请求建立连接，服务端 SYN_RCVD（同步接收）状态。
第三次握手
    客户端收到服务端报文数据包确认后，检查报文数据包是否正确，正确就处理数据包发送给服务端，服务端接收数据包检查是否正确，确认正确与客户端端建立连接，Client和Server进入 ESTABLISHED（已确认的）状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

![本地图片](/img/Handshake.jpg  "握手")

 #####  SYN攻击

 在三次握手过程中，Server发送报文之后，收到Client的报文之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到报文后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行。

 ```
    #netstat -nap | grep SYN_RECV
 ```


#### 四次挥手

第一次挥手
    客户端发送报文到服务端，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手
    服务端收到报文后，确认报文后，服务端进入CLOSE_WAIT状态。
第三次挥手
    服务端发起报文到客户端，告诉客户端，关闭从服务端到客户端的数据传输，Server进入LAST_ACK状态。
第四次挥手
    客户端收到报文后，客户端进入TIME_WAIT状态，接着发送一个报文到服务端，服务端确认后，Server进入CLOSED状态，完成四次挥手。
![本地图片](/img/wave.png  "挥手")

为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
  这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。